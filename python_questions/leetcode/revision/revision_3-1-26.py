# REVSION 3/1/26
# (Do in order. Do not skip instruction lines.)

# SET 1 — PREFIX SUM FUNDAMENTALS
# Instruction: Do NOT code first. Write the prefix sum array and explain what each index represents.
# 1480 - Running Sum of 1D Array
# 724 - Find Pivot Index
# 303 - Range Sum Query - Immutable
# Goal: Prefix sums should feel obvious, not clever.

# SET 2 — PREFIX SUM + COUNTING (CRITICAL SET)
# Instruction: For each problem, write:
# (1) what the prefix sum means
# (2) what the hashmap stores
# (3) when the answer increases
# 560 - Subarray Sum Equals K
# 525 - Contiguous Array
# 930 - Binary Subarrays With Sum
# 1248 - Count Number of Nice Subarrays
# Goal: Permanently separate counting subarrays from sliding window in your brain.

# SET 3 — FIXED SLIDING WINDOW
# Instruction: Solve in one pass using a running sum.
# No maps. No extra arrays.
# 643 - Maximum Average Subarray I
# Goal: Window mechanics should be automatic.

# SET 4 — VARIABLE SLIDING WINDOW (AT MOST / MIN SIZE)
# Instruction: Before coding, state the rule for when the left pointer moves.
# 209 - Minimum Size Subarray Sum
# 904 - Fruit Into Baskets
# 1004 - Max Consecutive Ones III
# Goal: Learn when shrinking is mandatory, not optional.

# SET 5 — TWO POINTERS (OPPOSITE ENDS)
# Instruction: Explain why moving the “worse” pointer is always safe before coding.
# 11 - Container With Most Water
# 75 - Sort Colors
# Goal: Trust pointer movement logic instead of brute force.

# SET 6 — GREEDY STATE TRACKING
# Instruction: Write the state variables and what invariant they maintain.
# 121 - Best Time to Buy and Sell Stock
# 334 - Increasing Triplet Subsequence
# Goal: Understand what information is worth keeping — and what isn't.

# SET 7 — DYNAMIC PROGRAMMING (SINGLE STATE)
# Instruction: Define the recurrence in plain English before writing code.
# 53 - Maximum Subarray
# Goal: Stop thinking DP is “arrays + loops”.

# SET 8 — DUAL-STATE DP (MIND-BENDER SET)
# Instruction: Explicitly track both “best” and “worst” at every step.
# 152 - Maximum Product Subarray
# Goal: Accept that negatives flip reality.

# SET 9 — BOUNDARY / WALL LOGIC
# Instruction: Draw the left max and right max arrays or pointers on paper first.
# 42 - Trapping Rain Water
# Goal: Think in boundaries, not elements.

# SET 10 — IN-PLACE ARRAY MANIPULATION
# Instruction: Memorize the steps.
# Do NOT try to re-derive.
# 31 - Next Permutation
# Goal: Treat this like long division — procedural memory is fine.

# FINAL RULE FOR THE DAY
# If you can:
# classify the pattern in under 30 seconds
# explain the core idea without code
# The problem is locked in memory.
